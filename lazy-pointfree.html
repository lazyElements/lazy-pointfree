<link rel="import" href="../polymer/polymer.html">

<!--
`lazy-pointfree`


@demo demo/index.html
-->

<script>
  const lazyPointfree = (su) => class extends su{
    compose(...fnArr){
      return value => fnArr.reduce((curr, fn) => {
        try{
          return fn(curr);
        }catch(e){
          throw e;
        }
      }, value);
    }

    curry(fn, ..._preArgs) {
      return (args) => {
        let concatArgs = [..._preArgs, ...args];
        if(concatArgs.length >= fn.length){
          return fn(...concatArgs.slice(0, fn.length));
        }
        return this.curry(fn, ...concatArgs);
      }
    }

    split(sep){
      return str => str.split(sep);
    }

    prop(p){
      return obj => obj[p];
    }

    gt(num){
      return val => val > num;
    }

    gte(num){
      return val => val >= num;
    }

    lt(num){
      return val => val < num;
    }

    lte(num){
      return val => val <= num;
    }

    sum(arr){
      return arr.reduce((curr, num) => Number(curr) + Number(num), 0);
    }

    max(arr){
      return arr.reduce((curr, num) => curr < num ? num : curr, 0);
    }

    min(arr){
      return arr.reduce((curr, num) => curr > num ? num: curr, 999999999999);
    }

    isNaN(){
      return num => isNaN(num);
    }

    isNull(){
      return val => val === null;
    }

    isUndefined(){
      return val => val === undefined;
    }

    add(num){
      return val => Number(val) + num;
    }

    subtract(num){
      return val => Number(val) - num;
    }

    isEmpty(){
      return val => [this.isNaN, this.isNull, this.isUndefined].every(fn => fn(val));
    }

    toArray(){
      return obj => Object.keys(obj).map(key => [{key: key, value:obj[key]}]);
    }

    filter(fn){
      return arr => arr.filter(fn);
    }

    map(fn){
      return arr => arr.map(fn);
    }

    every(fn){
      return arr => arr.every(fn);
    }

    some(fn){
      return arr => arr.some(fn);
    }
  }
</script>
